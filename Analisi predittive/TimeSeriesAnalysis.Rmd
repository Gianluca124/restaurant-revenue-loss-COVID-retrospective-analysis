---
title: "Ristorante 1 - Montebello"
output:
  prettydoc::html_pretty:
    df_print: paged
    highlight: vignette
    theme: architect
    toc: yes
    toc_depth: 5
  beamer_presentation:
    colortheme: lily
    fig_caption: no
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    theme: Hannover
    toc: yes
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '5'
  pdf_document:
    toc: yes
    toc_depth: 5
  slidy_presentation:
    highlight: default
  ioslides_presentation:
    css:
    - css/fonts.css
    - css/custom.css
    - css/title-slide.css
    - css/slide-background.css
    includes:
      before_body: html/TimeSeriesAnalysis.html
    toc: yes
    transition: default
    widescreen: yes
course: Progetto Data Science Lab
---

```{r setup, include=FALSE}
# Use 'verbatim = TRUE' as chunk option to show chunk code as is
require(knitr)
hook_source_def = knit_hooks$get('source')
knit_hooks$set(source = function(x, options){
  if (!is.null(options$verbatim) && options$verbatim){
    opts = gsub(",\\s*verbatim\\s*=\\s*TRUE\\s*", "", options$params.src)
    bef = sprintf('\n\n    ```{r %s}\n', opts, "\n")
    stringr::str_c(bef, paste(knitr:::indent_block(x, "    "), collapse = '\n'), "\n    ```\n")
  } else {
     hook_source_def(x, options)
  }
})
```

# Ristorante 1 - Montebello

```{r}
# Clean Workspace
rm(list=ls())
```

## Setting

```{r}
set.seed(100)

# Setting librerie utili
# Package names
packages <- c("readxl",  "readr", "forecast", "dplyr", "ggplot2",
              "lubridate", "KFAS", "tseries", "xts") 

# Install packages if not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Packages loading
invisible(lapply(packages, library, character.only = TRUE))


# Setting working directory
# working_dir = percorso cartella dati
# working_dir = "~/GitHub/Data-Science-Lab"
# setwd(working_dir)

# Funzione utile 
mape <- function(actual,pred){
  mape <- mean(abs((actual - pred)/actual))*100
  return (mape)
}
```

## Caricamento dataset

```{r}
# ristorante1 <- read.csv("ristorante1.csv")
ristorante1 <- read.csv(file.choose())
ristorante1$data  <- parse_date(ristorante1$data, "%Y-%m-%d", locale = locale("it"))
head(ristorante1)
```

## Data preparation

Somma dei valori NaN. Risultano essere 300 in quanto fino al 01/09/2018 il dato disponibile del fatturato è mensile, mentre dopo tale data il dato del fatturato è giornaliero. Inoltre, alcuni valori sono NaN in corrispondenza di alcune festività (i.e. 25/12).

```{r}
sum(is.na(ristorante1$scontrini))

```

```{r}
# Consideriamo solo i dati giornalieri e le colonne Data e lordototale
ts <- ristorante1[-c(1:243), c(6,8)]
# ts$data <- parse_date(ts$data, "%Y-%m-%d", locale = locale("it"))
str(ts)
```

```{r}
# Impostiamo a zero i valori NaN durante il periodo Covid (primo LockDown)
# Data di riferimento: 12-03-2020 --> 06/05/2020
ts$lordototale[ts$data >= '2020-03-12' & ts$data <= '2020-05-06'] <- 0
plot(ts$lordototale, type='l')
```

```{r}
# Trasformo ts in oggetto xts
xts1 <- as.xts(ts[,-1], order.by = ts[,1])
head(xts1)
```

```{r}
print(ts[is.na(ts$lordototale)==TRUE,])
# Presenti ancora alcui valori nulli. In particolare, si nota come tali valori mancanti siano in prossimità di alcunne feste nazionali, dove probabilmente il punto vendita era chiuso
```

```{r}
require(imputeTS)
ggplot_na_distribution(xts1) # Distribuzione dei valori nulli
statsNA(xts1)
```

```{r}
require(imputeTS)
# Imputazione dei valori nulli. Utilizzo della libreria "impute TS" con metodo "StructTS" che fa uso della massima verosimiglianza
xts1_noNA <- na_kalman(xts1, model = "StructTS", smooth = TRUE) # Utilizzo del filtro di kalman
ggplot_na_imputations(xts1, xts1_noNA)
```
```{r}
# Salvo l'oggetto xts1_noNA
write.zoo(xts1_noNA, file="ristorante1_xts.csv", sep=",")
```

# Domanda di ricerca1: analisi predittiva mediante modelli della classe ARIMA della serie storica pre-Covid ai fini di stimare le possibili perdite durante il primo periodo Covid



```{r}
# Estraggo il subset di interesse
# Data di riferimento: 23/02/2020 --> inizio delle restrizioni (23 e non 21, data ufficiale chiusura Università, così da avere la settimana completa)
xts1_subset <- window(xts1_noNA, start = "2018-09-03", end="2020-02-23")
autoplot(xts1_subset)
```
```{r}
plot(xts1_subset[1:70]) # Prime 10 settimane
```
```{r}
# Numero di settimane
noWe <- round(539/7)

# Valutiamo se c'è una qualche forma di dipendenza tra media e varianza
med <- tapply(xts1_subset, rep(1:noWe, each = 7)[1:539],
              mean)
stdev <- tapply(xts1_subset, rep(1:noWe, each = 7)[1:539],
              sd)
plot(med, stdev)
```
```{r}
plot(log(xts1_subset[1:70]))
```
```{r}
Acf(xts1_noNA, 140)
```






























```{r}
mstl(ristorante1_xts_subset, speriod = c(7,365.25)) %>% autoplot() # Non mi stima la stagionalità
```

```{r}
Acf(ristorante1_xts_subset, lag.max = 70)
Pacf(ristorante1_xts_subset, lag.max = 70)
```

Tramite la funzione di autocorrelazione, possiamo notare come siano particolarmente significativi i ritardi multipli di 7, indice di una stagionalità settimanale dei dati. Analizzando la funzione più nel dettaglio, sono significativi non solo i ritardi stagionali, indice di una non stazionarietà della serie storica. Proviamo quindi a considerare una differenza stagionale della serie storica.

```{r}
diff7_ristorante1 <- diff(ristorante1_xts_subset,7)
autoplot(diff7_ristorante1)
```

```{r}
Acf(diff7_ristorante1, 70)
Pacf(diff7_ristorante1, 70)
```

La funzione di autocorrelazione della serie storica differenziata stagionalmente evidenza un miglioramento in termini di ritardi significativi, anche se permangono autocorrelazioni significative ad alcuni ritardi (2,7 in particolare). Per quanto riguarda la funzione di autocorrelazione parziale i ritardi che presentano autocorrelazioni significative aumentano decisamente.

```{r}
diff(diff7_ristorante1) %>% autoplot()
```

```{r}
diff(diff7_ristorante1) %>% Acf()
diff(diff7_ristorante1) %>% Pacf()
```

La differenza stagionale ha portato miglioramenti in termini di Acf e Pacf, mentre la differenza semplice(applicata alla serie storica già differenziata stagionalmente) non ha migliorato la situazione. Procediamo considerando la serie storica differenziata solo stagionalmente. \\

Proviamo a considerare una trasformazione logaritmica per esplorare una possibile non stazionarietà in varianza.

```{r}
log(ristorante1_xts_subset) %>% autoplot()
```

La situazione non sembra cambiare. Tramite la funzione BoxCox.lambda andiamo a vedere quale sarebbe stato il valore di lambda stimato da R (ricordiamo che se =0 allora trasformazione logaritmica)

```{r}
BoxCox.lambda(ristorante1_xts_subset)
```

```{r}
BoxCox(ristorante1_xts_subset, lambda = "auto") %>% autoplot()
```

```{r}
diff(BoxCox(ristorante1_xts_subset, lambda = "auto"),7) %>% autoplot()
```

```{r}
diff(BoxCox(ristorante1_xts_subset, lambda = "auto"),7) %>% Acf()
diff(BoxCox(ristorante1_xts_subset, lambda = "auto"),7) %>% Pacf()
```

L'Acf e la Pacf della serie storica a cui viene applicato una trasformazione di BoxCox e differenziata stagionalmente sembra aver ulteriormente migliorato i risultato in termini di stazionarietà della serie storica. Bisognerà poi verificare se è possibile applicare una differenziazione stagionale all'interno della specificazione del modello (non è detto che il modello riesca a beccare la stagionalità) oppure se è necessario dare in pasto al modello la serie storica differenziata di ordine 7

Procediamo quindi alla fase di specificazione di un modello della classe Arima.

```{r}
# Salviamo la serie storica differenziata di ordine 7
ristorante1_xts_subset_diff <- diff(ristorante1_xts_subset, 7)
```

## Specificazione del modello

```{r}
# Divisione training and test della serie storica originaria
train <- head(ristorante1_xts_subset, round(length(ristorante1_xts_subset) * 0.8))
h <- length(ristorante1_xts_subset) - length(train)
test <- tail(ristorante1_xts_subset, h)
```

```{r}
# Divisione training and test della serie storica differnziata di ordine 7
train_diff <- head(ristorante1_xts_subset_diff, round(length(ristorante1_xts_subset_diff) * 0.8))
h_diff <- length(ristorante1_xts_subset_diff) - length(train_diff)
test_diff <- tail(ristorante1_xts_subset_diff, h_diff)
```

```{r}
mod1 <- Arima(train, order = c(7,1,7), seasonal = c(0,0,0))
Acf(mod1$residuals)
Pacf(mod1$residuals)
summary(mod1)
```

```{r}
# Significatività dei parametri (p-value)
(1-pnorm(abs(mod1$coef)/sqrt(diag(mod1$var.coef))))*2
```

Valutiamo se i residui presentano autocorrelazione seriale.

```{r}
Box.test(residuals(mod1),lag=28,type="Ljung-Box")
```

Previsione e confronto con il test set

```{r}
# Previsioni modello Arima
forecast(mod1, 108) %>% autoplot()
```

```{r}
# Sistemare
fitted_mod1 <- as.data.frame()
fitted_mod1['Date'] <- ristorante1[677:784,6]
fitted_mod1_xts <- as.xts(fitted_mod1[,-2], order.by = fitted_mod1[,2])
diff_fitt_test <- test - fitted_mod1_xts
```

```{r}
plot(test,
     col=2
     )
lines(fitted_mod1_xts,
      col=4
      )
legend("topright",
       c("Test", "Fitted"),
       col=c(2,4)
       )
```

```{r}
mean(diff_fitt_test)
plot(diff_fitt_test)
```

```{r}
# Serie storica differenziata di ordine 7
mod2 <- Arima(train_diff, c(7,0,7), c(0,0,0))
```

```{r}
Acf(mod2$residuals)
Pacf(mod2$residuals)
summary(mod2)
```

### Aggregazione: serie storica settimanale

```{r}
head(ristorante1_xts) # I dati partono da sabato
tail(ristorante1_xts) #  I dati finiscono di sabato (ultimo e penultimo valori 0.0)
```

```{r}
# Droppo le prime due righe e le ultime 4 così da avere la serie storica che parte da lunedì e finisce di domenica
ristorante1_xts <- ristorante1_xts[-c(1,2)]
ristorante1_xts <- ristorante1_xts[-c(1329,1330,1331,1332,1333,1334)]
head(ristorante1_xts)
tail(ristorante1_xts)
```

```{r}
ristorante1_weekly <- apply.weekly(ristorante1_xts[-c(1,2)], mean)
```

```{r}
head(ristorante1_weekly)
tail(ristorante1_weekly)
```

```{r}
plot(ristorante1_weekly)
```

```{r}
# Estraggo il subset di interesse
ristorante1_weekly_subset <-window(ristorante1_weekly, start = "2018-09-01", end="2020-02-23")
tail(ristorante1_weekly_subset)
```

```{r}
autoplot(ristorante1_weekly_subset)
```

```{r}
seasadj(mstl(ristorante1_weekly_subset, s.window = 52)) %>% autoplot()
```

```{r}
ndiffs(ristorante1_weekly_subset)
nsdiffs(ristorante1_weekly_subset)
```

```{r}
mstl(ristorante1_weekly_subset, s.window = "periodic") %>% autoplot() 
```

```{r}
diff(seasadj(mstl(ristorante1_weekly_subset, s.window = 52))) %>% autoplot()
```

```{r}
adf.test(diff(seasadj(mstl(ristorante1_weekly_subset, s.window = 52))), alternative = "stationary") 
```

```{r}
Acf(ristorante1_weekly_subset)
Pacf(ristorante1_weekly_subset)
```

```{r}
mod3 <- auto.arima(ristorante1_weekly_subset)
```

```{r}
Acf(mod3$residuals)
Pacf(mod3$residuals)
summary(mod3)
```

```{r}
plot(forecast(mod3,30))
```

