---
title: "Random Forest - Ristorante 1"
output:
  prettydoc::html_pretty:
    df_print: paged
    highlight: vignette
    theme: architect
    toc: yes
    toc_depth: 5
  beamer_presentation:
    colortheme: lily
    fig_caption: no
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    theme: Hannover
    toc: yes
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '5'
  pdf_document:
    toc: yes
    toc_depth: 5
  slidy_presentation:
    highlight: default
  ioslides_presentation:
    css:
    - css/fonts.css
    - css/custom.css
    - css/title-slide.css
    - css/slide-background.css
    includes:
      before_body: html/TimeSeriesAnalysis.html
    toc: yes
    transition: default
    widescreen: yes
course: Progetto Data Science Lab
---

```{r}
# Clean Workspace
rm(list=ls())
```

```{r setup, include=FALSE}
# Use 'verbatim = TRUE' as chunk option to show chunk code as is
require(knitr)
hook_source_def = knit_hooks$get('source')
knit_hooks$set(source = function(x, options){
  if (!is.null(options$verbatim) && options$verbatim){
    opts = gsub(",\\s*verbatim\\s*=\\s*TRUE\\s*", "", options$params.src)
    bef = sprintf('\n\n    ```{r %s}\n', opts, "\n")
    stringr::str_c(bef, paste(knitr:::indent_block(x, "    "), collapse = '\n'), "\n    ```\n")
  } else {
     hook_source_def(x, options)
  }
})
```

```{r}
set.seed(100)

# Setting librerie utili
# Package names
packages <- c("readxl",  "readr", "forecast", "dplyr", "ggplot2",
              "lubridate", "KFAS", "tseries", "xts", "randomForest") 

# Install packages if not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Packages loading
invisible(lapply(packages, library, character.only = TRUE))


# Setting working directory
# working_dir = "C:/Users/marco/OneDrive/UNIMIB_DataScience/99-PROJECTS/DataScienceLab2022/Dati ristoranti"
# setwd(working_dir)

# MAPE 
mape <- function(actual,pred){
  mape <- mean(abs((actual - pred)/actual))*100
  return (mape)
}

#MSE
rmse <- function(actual, pred){
  rmse <- sqrt(mean((actual - pred)^2))
  return (rmse)
}

# Significatività dei parametri
pars_test <- function(coef, var_coef){
  test <- (1-pnorm(abs(coef)/sqrt(diag(var_coef))))*2
  return(test)
}

# Grafico errore percentuale 
err_plot <- function(actual, pred){
  require(xts)
  err_perc <- ((actual - xts(pred, order.by = index(actual)))/(xts(actual, order.by = index(actual))))*100
  return(plot(err_perc, ylab="% errore", main="Errore percentuale di previsione"))

}
```

# Load data

```{r}
# file: Dati ristoranti\pre-covid_r1.csv
r1 <- read.csv("..\\Dati ristoranti\\pre-covid_r1.csv")
r1$data  <- parse_date(r1$data, "%Y-%m-%d", locale = locale("it"))
head(r1)
```

# Data preparation

```{r}
rf_r1 <- xts(r1[, "lordototale"], as.Date(as.character(r1$data), format = "%Y-%m-%d"))
```

```{r}
train_ndx <- nrow(r1)*0.8
validation_ndx <- train_ndx*0.9
```


# Primo tentativo: previsione solo con dati della serie storica

```{r}
train_validation <- rf_r1[1:train_ndx, ]
train <- train_validation[1:validation_ndx, ]
validation <- train_validation[-c(1:validation_ndx), ]
test <- rf_r1[-c(1:train_ndx), ]
```

# Estraggo la matrice con la serie storica come prima colonna e il numero di ritardi che voglio considerare come colonne ulteriori (7 in questo caso)

```{r}
# Ho provato con solo 7 ritardi, e le performance erano piuttosto scadenti. Con 14 ritardi (2 settimane) i risultati sono decisamente migliori
Y <- embed(train, 15) # numero di ritardi + 1 che vogliamo considerare
colnames(Y) <- c("y", paste0("y_", 1:14))
```

# Train modello

```{r}
rf1 <- randomForest(y~., data = Y)
print(rf1)
```
# Costruzione vettore stime - stima ricorsiva (ogni valore stimato viene utilizzato per prevedere il successivo)

```{r}
y_hat <- numeric(nrow(validation)) # Test con 39 osservazioni da stimare

# Matrice per le previsioni ricorsive

X <- Y[nrow(Y), -15, drop = FALSE] # Ultima riga della matrice utilizzata per il training, a cui tolgo il 7° ritardo (questi sono i ritardi per prevedere il valore al tempo t+1)
colnames(X) <- colnames(Y)[-1] # Il modello ha bisogno dei nomi esatti
```

# Previsioni

```{r}
for (h in 1:nrow(validation)) {
  y_hat[h] <- predict(rf1, X, predict.all = TRUE)$individual |> median() # predict.all=True mantiene la stima data da tutti gli alberi nella foresta. Dopodichè si vanno a selezionare tutti e a prenderne la mediana (in alternativa, la media)
  # Produco lo shift in X
  X[1, 2:14] <- X[1, 1:13]
  X[1, 1] <- y_hat[h]
}

pred <- as.xts(y_hat, order.by = date(validation))
```

# Confronto previsioni vs. test

```{r}
plot(validation, type = "l")
lines(pred, type = "l", col = "red")
```

# Performance

```{r}
mape(validation, pred)
rmse(validation, pred)
```

# Secondo tentativo - REGRESSORI

```{r}
# Tengo Festivo e Pioggia come regressori

rf_r1 <- xts(r1[, c("lordototale", "Festivo", "Pioggia")], as.Date(as.character(r1$data), format = "%Y-%m-%d"))

rf_r1$Festivo[rf_r1$Festivo=="False"] <- 0
rf_r1$Festivo[rf_r1$Festivo=="True"] <- 1

rf_r1$Pioggia[rf_r1$Pioggia==""] <- 0
rf_r1$Pioggia[rf_r1$Pioggia=="True"] <- 1
```


```{r}
# Costruisco i regressori da 0

yday <- yday(time(rf_r1))
wday <- wday(time(rf_r1), week_start = getOption("lubridate.week.start", 1))

data <- cbind(rf_r1, yday, wday)

data_train <- data[1:train_ndx, ]
```

```{r}
train_ndx2 <- 1:(validation_ndx-14)
valid_ndx2 <- (validation_ndx-14+1):(nrow(train_validation)-14)

X <- embed(data_train$lordototale, 15) # Numero di ritardi + 1

y <- X[, 1] # Variabile target

X <- cbind(X[, -1], data_train[-(1:14), c("Festivo","Pioggia","yday", "wday")]) # Regressori

# Split training-test

y_train <- y[train_ndx2]
X_train <- X[train_ndx2, ]

y_test <- y[valid_ndx2]
X_test <- X[valid_ndx2,]

# Addestramento modello

rf2 <- randomForest(X_train, y_train,
                    xtest = X_test,
                    ytest = y_test)

rf_pred2 <- rf2$test$predicted

plot(y_test, type = "l")
lines(rf_pred2, type="l", col = "red")

mape(y_test, rf_pred2)
rmse(y_test, rf_pred2)
```


