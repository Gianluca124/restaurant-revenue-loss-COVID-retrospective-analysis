---
title: "TSCrossValidation-Summary"
author: "Carbone Giorgio"
date: "2022-12-16"
output:
  prettydoc::html_pretty:
    df_print: paged
    highlight: vignette
    theme: architect
    toc: yes
    toc_depth: 5
  beamer_presentation:
    colortheme: lily
    fig_caption: no
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    theme: Hannover
    toc: yes
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '5'
  pdf_document:
    toc: yes
    toc_depth: 5
  slidy_presentation:
    highlight: default
  ioslides_presentation:
    css:
    - css/fonts.css
    - css/custom.css
    - css/title-slide.css
    - css/slide-background.css
    includes:
      before_body: html/TimeSeriesAnalysis.html
    toc: yes
    transition: default
    widescreen: yes
course: Progetto Data Science Lab
---

# Setup

```{r}
# Clean Workspace
rm(list=ls())
```

```{r setup, include=FALSE}
# Use 'verbatim = TRUE' as chunk option to show chunk code as is
require(knitr)
hook_source_def = knit_hooks$get('source')
knit_hooks$set(source = function(x, options){
  if (!is.null(options$verbatim) && options$verbatim){
    opts = gsub(",\\s*verbatim\\s*=\\s*TRUE\\s*", "", options$params.src)
    bef = sprintf('\n\n    ```{r %s}\n', opts, "\n")
    stringr::str_c(bef, paste(knitr:::indent_block(x, "    "), collapse = '\n'), "\n    ```\n")
  } else {
     hook_source_def(x, options)
  }
})
```

## Loading Libraries

```{r include=FALSE}
set.seed(100)

# Setting librerie utili
# Package names
packages <- c("readxl",  "readr", "forecast", "dplyr", "ggplot2",
              "lubridate", "KFAS", "tseries", "xts", "fastDummies", "TSstudio", "utils") 

# Install packages if not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Packages loading
invisible(lapply(packages, library, character.only = TRUE))
```

# Pre Covid

## Load Errors

```{r message=FALSE, warning=FALSE}
working_dir = dirname(rstudioapi::getSourceEditorContext()$path)
setwd(working_dir) # lo applica solo a questo chunk!

h = 74
folder_path <- "./Errors"
error_df_list_precovid <- list()


# Lista dei tipi di modelli
items <- list.files(folder_path, recursive = FALSE, full.names = TRUE)

for (dir in items) {
  csv_files <- list.files(path = dir, pattern = "*.csv", full.names = TRUE)
  filtered_csv_files <- csv_files %>% grep("PreCovid_e[0-9]+\\.csv$", ., value = TRUE)
  for (f in filtered_csv_files) {
    df <- read_csv(f)
    #df$date  <- parse_date(df$date, "%Y-%m-%d", locale = locale("it"))
    
    df <- xts(df[, c(-1,-2)], as.Date(as.character(df$date), format = "%Y-%m-%d"))
    colnames(df) <- paste("h=", 1:h, sep = "")
    
    
    var_name <- gsub("\\.csv$", "", basename(f))
    assign(var_name, df)
    
    # Aggiungo alla lista
    error_df_list_precovid[[var_name]] <- df
  }
}
```

### RMSE

```{r}
RMSE_PreCovid <- list()

for (df_name in names(error_df_list_precovid)) {
  # Accedi al dataframe nella lista utilizzando il suo nome
  df <- error_df_list_precovid[[df_name]]
  
  # Applica la funzione di tua scelta al dataframe
  result <- sqrt(colMeans(df^2, na.rm = TRUE))
  
  # Assegna il risultato a una variabile con il nome "RMSE_nomedeldataframe"
  result_name <- paste0("RMSE_", df_name)
  
  RMSE_PreCovid[[result_name]] <- result
}
```

```{r, eval=FALSE, echo=FALSE}
plot(1:74, NULL, type="l", col=1, xlab="horizon", ylab="RMSE", ylim = c(2000,10000))

for(i in 1:length(RMSE_PreCovid)) {
  #View(RMSE_PreCovid[[i]])
  lines(1:74, RMSE_PreCovid[[i]], col = i,  lty = i)
}

# Aggiungi la legenda al grafico
col = seq(1,length(RMSE_PreCovid))
plot(NULL ,xaxt='n',yaxt='n',bty='n',ylab='',xlab='', xlim=0:1, ylim=0:1)
lty = seq(1,length(RMSE_PreCovid))
legend("topright", legend = names(RMSE_PreCovid), col = col, lty = lty)

```

```{r}
# Crea una mappa per associare il nome di ogni vettore all'etichetta e al colore desiderati
i_x = 0
f_x = 74
by_x = 10

i_y = 2000
f_y = 10000
by_y = 1000

name_map <- list(
  "ARIMA" = list(label = "ARIMA", col = "red"),
  "UCM" = list(label = "UCM", col = "darkgreen"),
  "RandomForest" = list(label = "RF", col = "blue")
)

suffix_map <- list(
  "SARIMA(1,0,0)(1,1,2)",
  "ARIMAX (2,1,3)-dummy",
  "SARIMAX(3,1,2)(1,0,1)-fourier",
  "SARIMAX(3,1,3)(1,0,0)-regressori",
  "ritardi",
  "regressori",
  "regressori+dummy festività",
  "ritardi",
  "regressori",
  "regressori+dummy festività"
)

# Inizializza il grafico
#par(las = 0.5)

#plot(1:74, NULL, type="l", col=1, xlab="horizon", ylab="RMSE", ylim = c(2000,10000), xgap.axis = 1)

#png("highres.png", units = "in", width = 5, height = 4, res = 300)

#png("highres.png", res = 300)

#jpeg(file="saving_plot2.png", width=1280, height=720)

par(oma=c(0, 0, 0, 8), asp=1)

plot(x = NULL, y = NULL, type = "n", xlim = c(i_x, f_x), ylim = c(i_y, f_y),
     xlab="Forecast Horizon", ylab="RMSE",
     xaxt = "n",
     yaxt = "n", grid = TRUE)


int_seq_x <- append(seq.int(from = i_x, to = f_x, by = by_x), f_x)
axis(side = 1, at = int_seq_x)
int_seq_y <- append(seq.int(from = i_y, to = f_y, by = by_y), f_y)
axis(side = 2, at = int_seq_y)

abline(v = int_seq_x, lty = "dotted", col = "lightgray")
abline(h = int_seq_y, lty = "dotted", col = "lightgray")

# Crea un vettore di tratti per ogni etichetta
lty_map <- list()
for (label in names(name_map)) {
  lty_map[[label]] <- seq(1, length(grep(label, names(RMSE_PreCovid))))
}

# Plotta le linee per ogni vettore nella lista
counter_map <- list()
for(i in 1:length(RMSE_PreCovid)) {
  # Trova l'etichetta corrispondente al nome del vettore
  label <- NULL
  for (key in names(name_map)) {
    if (grepl(key, names(RMSE_PreCovid[i]))) {
      label <- key
      break
    }
  }
  
  if (!is.null(label)) {
    # Inizializza il contatore per il gruppo corrente, se non ancora presente
    if (!(label %in% names(counter_map))) {
      counter_map[[label]] <- 1
    }
    
    # Plotta la linea usando il colore e il tratto corrispondenti all'etichetta
    lines(1:74, RMSE_PreCovid[[i]], col = name_map[[label]]$col, lty = lty_map[[label]][counter_map[[label]]])
    
    # Incrementa il contatore per il gruppo corrente
    counter_map[[label]] <- counter_map[[label]] + 1
  }
}

# Aggiungi la legenda al grafico
col <- c()
lty <- c()
labels <- c()
for (key in names(name_map)) {
  col <- c(col, rep(name_map[[key]]$col, length(grep(key, names(RMSE_PreCovid)))))
  lty <- c(lty, lty_map[[key]])
  labels <- c(labels, 
              paste(rep(name_map[[key]]$label, length(grep(key, names(RMSE_PreCovid)))), suffix_map[grep(key, names(RMSE_PreCovid))], sep="-"))
}
#plot(NULL ,xaxt='n',yaxt='n',bty='n',ylab='',xlab='', xlim=0:1, ylim=0:1)
#legend("topright", legend = labels, col = col, lty = lty)
#legend(side = "topright", bty = "o", cex = 0.8, x.intersp = 1.5, legend = labels, col = col, lty = lty)

legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,
       legend = labels, col = col, lty = lty)

```

```{r, eval=FALSE, echo=FALSE}
# Crea una mappa per associare il nome di ogni vettore all'etichetta e al colore desiderati
name_map <- list(
  "ARIMA" = list(label = "ARIMA", col = "red"),
  "UCM" = list(label = "UCM", col = "black"),
  "RandomForest" = list(label = "Random Forest", col = "blue")
)

# Inizializza il grafico
#par(las = 0.5)
plot(1:74, NULL, type="l", col=1, xlab="horizon", ylab="RMSE", ylim = c(2000,10000), xgap.axis = 1, 
     xaxt='n')
grid(col = "lightgray", lty = "dotted")

# Crea un vettore di tratti per ogni etichetta
lty_map <- list()
for (label in names(name_map)) {
  lty_map[[label]] <- seq(1, length(grep(label, names(RMSE_PreCovid))))
}

# Plotta le linee per ogni vettore nella lista
counter_map <- list()
for(i in 1:length(RMSE_PreCovid)) {
  # Trova l'etichetta corrispondente al nome del vettore
  label <- NULL
  for (key in names(name_map)) {
    if (grepl(key, names(RMSE_PreCovid[i]))) {
      label <- key
      break
    }
  }
  
  if (!is.null(label)) {
    # Inizializza il contatore per il gruppo corrente, se non ancora presente
    if (!(label %in% names(counter_map))) {
      counter_map[[label]] <- 1
    }
    
    # Plotta la linea usando il colore e il tratto corrispondenti all'etichetta
    lines(1:74, RMSE_PreCovid[[i]], col = name_map[[label]]$col, lty = lty_map[[label]][counter_map[[label]]])
    
    # Incrementa il contatore per il gruppo corrente
    counter_map[[label]] <- counter_map[[label]] + 1
  }
}

# Aggiungi la legenda al grafico
col <- c()
lty <- c()
labels <- c()
for (key in names(name_map)) {
  col <- c(col, rep(name_map[[key]]$col, length(grep(key, names(RMSE_PreCovid)))))
  lty <- c(lty, lty_map[[key]])
  labels <- c(labels, rep(name_map[[key]]$label, length(grep(key, names(RMSE_PreCovid)))))
}
plot(NULL ,xaxt='n',yaxt='n',bty='n',ylab='',xlab='', xlim=0:1, ylim=0:1)
legend("topright", legend = labels, col = col, lty = lty)

```


### RMdSE

```{r}
library(robustbase)
RMdSE_PreCovid <- list()

for (df_name in names(error_df_list_precovid)) {
  # Accedi al dataframe nella lista utilizzando il suo nome
  df <- error_df_list_precovid[[df_name]]
  
  # Applica la funzione di tua scelta al dataframe
  result <- sqrt(colMedians(df^2, na.rm = TRUE, hasNA = TRUE))
  
  # Assegna il risultato a una variabile con il nome "RMSE_nomedeldataframe"
  result_name <- paste0("RMdSE_", df_name)
  
  RMdSE_PreCovid[[result_name]] <- result
}
```

```{r}
plot(1:74, NULL, type="l", col=1, xlab="horizon", ylab="RMdSE", ylim = c(1000,4000))

for(i in 1:length(RMdSE_PreCovid)) {
  #View(RMSE_PreCovid[[i]])
  lines(1:74, RMdSE_PreCovid[[i]], col = i,  lty = i)
}

# Aggiungi la legenda al grafico
col = seq(1,length(RMdSE_PreCovid))
plot(NULL ,xaxt='n',yaxt='n',bty='n',ylab='',xlab='', xlim=0:1, ylim=0:1)
lty = seq(1,length(RMdSE_PreCovid))
legend("topright", legend = names(RMdSE_PreCovid), col = col, lty = lty)

```

```{r, eval=FALSE, echo=FALSE}}
RMdSE_mod1 <- sqrt(colMedians(e1^2, na.rm = TRUE, hasNA = TRUE))
RMdSE_mod2 <- sqrt(colMedians(e2^2, na.rm = TRUE, hasNA = TRUE))
RMdSE_mod3 <- sqrt(colMedians(e3^2, na.rm = TRUE, hasNA = TRUE))

# Zoom in
plot(1:42, RMdSE_mod1, type="l", col=1, xlab="horizon", ylab="RMdSE", ylim = c(0,5000))
lines(1:42, RMdSE_mod2, type="l",col=2)
lines(1:42, RMdSE_mod3, type="l",col=3)
legend("topleft",legend=c("1_RandomForest_noregr","2_RandomForest_regr","3_RandomForest_regr_DUmmy"),col=1:3,lty=1)

```

### MAE

```{r}
MAE_PreCovid <- list()

for (df_name in names(error_df_list_precovid)) {
  # Accedi al dataframe nella lista utilizzando il suo nome
  df <- error_df_list_precovid[[df_name]]
  
  # Applica la funzione di tua scelta al dataframe
  result <- colMeans(abs(df), na.rm = TRUE)
  
  # Assegna il risultato a una variabile con il nome "MAE_nomedeldataframe"
  result_name <- paste0("MAE_", df_name)
  
  MAE_PreCovid[[result_name]] <- result
}
```

```{r}
# Crea una mappa per associare il nome di ogni vettore all'etichetta e al colore desiderati
i_x = 0
f_x = 74
by_x = 10

i_y = 1800
f_y = 4800
by_y = 200
ylab = "MAE"

name_map <- list(
  "ARIMA" = list(label = "ARIMA", col = "red"),
  "UCM" = list(label = "UCM", col = "darkgreen"),
  "RandomForest" = list(label = "Random Forest", col = "blue")
)

suffix_map <- list(
  "SARIMA(1,0,0)(1,1,2)",
  "ARIMAX (2,1,3)-dummy",
  "SARIMAX(3,1,2)(1,0,1)-fourier",
  "SARIMAX(3,1,3)(1,0,0)-regressori",
  "ritardi",
  "regressori",
  "regressori+dummy festività",
  "ritardi",
  "regressori",
  "regressori+dummy festività"
)

# Inizializza il grafico
#par(las = 0.5)

#plot(1:74, NULL, type="l", col=1, xlab="horizon", ylab="MAE", ylim = c(2000,10000), xgap.axis = 1)

#png("highres.png", units = "in", width = 5, height = 4, res = 300)

#png("highres.png", res = 300)

#jpeg(file="saving_plot2.png", width=1280, height=720)

par(oma=c(0, 0, 0, 8), asp=1)

plot(x = NULL, y = NULL, type = "n", xlim = c(i_x, f_x), ylim = c(i_y, f_y),
     xlab="Forecast Horizon", ylab=ylab,
     xaxt = "n",
     yaxt = "n", grid = TRUE)


int_seq_x <- append(seq.int(from = i_x, to = f_x, by = by_x), f_x)
axis(side = 1, at = int_seq_x)
int_seq_y <- append(seq.int(from = i_y, to = f_y, by = by_y), f_y)
axis(side = 2, at = int_seq_y)

abline(v = int_seq_x, lty = "dotted", col = "lightgray")
abline(h = int_seq_y, lty = "dotted", col = "lightgray")

# Crea un vettore di tratti per ogni etichetta
lty_map <- list()
for (label in names(name_map)) {
  lty_map[[label]] <- seq(1, length(grep(label, names(MAE_PreCovid))))
}

# Plotta le linee per ogni vettore nella lista
counter_map <- list()
for(i in 1:length(MAE_PreCovid)) {
  # Trova l'etichetta corrispondente al nome del vettore
  label <- NULL
  for (key in names(name_map)) {
    if (grepl(key, names(MAE_PreCovid[i]))) {
      label <- key
      break
    }
  }
  
  if (!is.null(label)) {
    # Inizializza il contatore per il gruppo corrente, se non ancora presente
    if (!(label %in% names(counter_map))) {
      counter_map[[label]] <- 1
    }
    
    # Plotta la linea usando il colore e il tratto corrispondenti all'etichetta
    lines(1:74, MAE_PreCovid[[i]], col = name_map[[label]]$col, lty = lty_map[[label]][counter_map[[label]]])
    
    # Incrementa il contatore per il gruppo corrente
    counter_map[[label]] <- counter_map[[label]] + 1
  }
}

# Aggiungi la legenda al grafico
col <- c()
lty <- c()
labels <- c()
for (key in names(name_map)) {
  col <- c(col, rep(name_map[[key]]$col, length(grep(key, names(MAE_PreCovid)))))
  lty <- c(lty, lty_map[[key]])
  labels <- c(labels, 
              paste(rep(name_map[[key]]$label, length(grep(key, names(MAE_PreCovid)))), suffix_map[grep(key, names(MAE_PreCovid))], sep="-"))
}
#plot(NULL ,xaxt='n',yaxt='n',bty='n',ylab='',xlab='', xlim=0:1, ylim=0:1)
#legend("topright", legend = labels, col = col, lty = lty)
#legend(side = "topright", bty = "o", cex = 0.8, x.intersp = 1.5, legend = labels, col = col, lty = lty)

legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,
       legend = labels, col = col, lty = lty)

```

### MAPE

```{r}
MAPE_mod1 <- colMeans(abs(e1_percentage), na.rm = TRUE)
MAPE_mod2 <- colMeans(abs(e2_percentage), na.rm = TRUE)
MAPE_mod3 <- colMeans(abs(e3_percentage), na.rm = TRUE)

plot(1:42, MAPE_mod1, type="l", col=1, xlab="horizon", ylab="MAPE", ylim = c(0,100))
lines(1:42, MAPE_mod2, type="l",col=2)
lines(1:42, MAPE_mod3, type="l",col=3)
legend("topleft",legend=c("1_RandomForest_noregr","2_RandomForest_regr","3_RandomForest_regrDummy"),col=1:3,lty=1)
```