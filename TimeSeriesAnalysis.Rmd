---
title: "Ristorante 1 - Montebello"
output:
  prettydoc::html_pretty:
    df_print: paged
    highlight: vignette
    theme: architect
    toc: yes
    toc_depth: 5
  beamer_presentation:
    colortheme: lily
    fig_caption: no
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    theme: Hannover
    toc: yes
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '5'
  pdf_document:
    toc: yes
    toc_depth: 5
  slidy_presentation:
    highlight: default
  ioslides_presentation:
    css:
    - css/fonts.css
    - css/custom.css
    - css/title-slide.css
    - css/slide-background.css
    includes:
      before_body: html/Ristorante1.html
    toc: yes
    transition: default
    widescreen: yes
course: Decision Models
---

```{r setup, include=FALSE}
# Use 'verbatim = TRUE' as chunk option to show chunk code as is
require(knitr)
hook_source_def = knit_hooks$get('source')
knit_hooks$set(source = function(x, options){
  if (!is.null(options$verbatim) && options$verbatim){
    opts = gsub(",\\s*verbatim\\s*=\\s*TRUE\\s*", "", options$params.src)
    bef = sprintf('\n\n    ```{r %s}\n', opts, "\n")
    stringr::str_c(bef, paste(knitr:::indent_block(x, "    "), collapse = '\n'), "\n    ```\n")
  } else {
     hook_source_def(x, options)
  }
})
```

# Ristorante 1 - Montebello

```{r}
# Clean Workspace
rm(list=ls())
```

## Setting

```{r}
set.seed(100)

# Setting librerie utili
# Package names
packages <- c("readxl",  "readr", "forecast", "dplyr", "magrittr", "ggplot2",
              "forcats", "lubridate", "RQuantLib", "devtools", "patchwork", "KFAS",
              "caret", "tseries", "urca", "TSstudio", "gridExtra", "randomForest",
              "prophet", "xts", "corrplot", "rstan", "hydroTSM") 

# Install packages if not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Packages loading
invisible(lapply(packages, library, character.only = TRUE))


# Setting working directory
# working_dir = percorso cartella dati
# working_dir = "~/GitHub/Data-Science-Lab"
# setwd(working_dir)

# Funzione utile 
mape <- function(actual,pred){
  mape <- mean(abs((actual - pred)/actual))*100
  return (mape)
}
```

## Caricamento dataset

```{r}
# ristorante1 <- read.csv("ristorante1.csv")
ristorante1 <- read.csv(file.choose())
```

## Data preparation

Somma dei valori NaN. Risultano essere 300 in quanto fino al 01/09/2018 il dato disponibile del fatturato è mensile, mentre dopo tale data il dato del fatturato è giornaliero

```{r}
sum(is.na(ristorante1$scontrini))

```

Definiamo il formato della data e consideriamo solo i dati giornalieri relativi al fatturato, impostando a 0 i valori nulli.

```{r}
ristorante1$data  <- parse_date(ristorante1$data, "%Y-%m-%d", locale = locale("it"))
ristorante1$lordototale[is.na(ristorante1$lordototale)] <- 0 
ristorante1_tsFatturato <- ristorante1[-c(1:243), c(6,8)]
ristorante1_tsFatturato
```

```{r}
str(ristorante1_tsFatturato)
```

```{r}
# Trasformo il dataframe in oggetto xts
ristorante1_xts <- as.xts(ristorante1_tsFatturato[,-1], order.by = ristorante1_tsFatturato[,1])
head(ristorante1_xts)
```

```{r}
# inds <- seq(as.Date("2018-09-01"), as.Date("2022-04-30"), by="day")
# ristorante1_ts <- ts(ristorante1_tsFatturato[,2], frequency = 365, start = c(2018, as.numeric(format(inds[1], "%j"))))
```

```{r}
plot(ristorante1_xts)
```

Stima delle componenti della serie storica: trend, stagionalità e serie storica dei residui

```{r}
mstl(ristorante1_xts, s.window = c(7, 365.25)) %>% autoplot() # Non mi stima la stagionalità, problema delle serie storiche giornalierie, che presentano solitamente stagionalità multiple!
```

```{r}
ristorante1_ts <- xts_to_ts(ristorante1_xts, frequency = 365, start = as.Date("2018-09-01"))
mstl(ristorante1_ts[,1], s.window = "periodic") %>% autoplot() # Stagionalità stimata, stima del trend oscena!
```

## Time series analysis

In questa sezion33e l'obiettivo è quello di considerare la serie storica fino all'inizio della pandemia e stimare un opportuno modello Arima. Per fare ciò si divide tale porzione di serie storica in training and test set, per valutare la bontà del modello stimato. Una volta indivuato il modello corretto si vuole effetturare una previsione per il "primo" periodo covid, così da poter dare una idea delle possibile perdite subite dal locale. L'idea alla base è quella di effetturare una previsione proveniente da una serie storica dove si assume che il ristorante operava in "condizioni normali", ovvero in condizioni di assenza della pandemia, per poter dare una idea di quanto il ristorante avrebbe potuto incassare qualora in covid non ci fosse stato. Si noti che tale previsione può solo dare una idea dell'ordine di grandezza della possibile perdita in quanto la previsione è effettuata considerando solo i dati storici e non considerando evenutali regressori che potrebbero influenzare gli incassi "attesi" (ad esempio: costo delle materie prime, eventuali altre aperture di ristoranti nella stessa zona ecc..)

### Domanda 1: Seguendo l'andamento pre-Covid, si vuole stimare quale possa essere stata la perdita, in termini di fatturato, nel periodo covid

A tal fine, viene stimato un opportuno modello ARIMA sui soli dati pre-Covid e viene prodotta successivamente una previsione per il periodo Covid. Infine, si calcola la differenza tra i valori osservati durante il periodo Covid con quelli ottenuti dalla stima del modello ARIMA. Così facendo possiamo dare una idea delle possibili perdite subite in tal periodo.

Subset serie storica pre-Covid: Si considera come data ufficiosa il 23 di Febbraio, giorno dell'entrata in vigore delle prime restrizioni (chiusura Università).

```{r}
# Estraggo il subset di interesse
ristorante1_xts_subset <- window(ristorante1_xts, start = "2018-09-01", end="2020-02-23")
plot(ristorante1_xts_subset)
summary(ristorante1_xts_subset)
hist(ristorante1_xts_subset)
```

```{r}
mstl(ristorante1_xts_subset, speriod = c(7,365.25)) %>% autoplot() # Non mi stima la stagionalità
```

```{r}
Acf(ristorante1_xts_subset, lag.max = 70)
Pacf(ristorante1_xts_subset, lag.max = 70)
```

Tramite la funzione di autocorrelazione, possiamo notare come siano particolarmente significativi i ritardi multipli di 7, indice di una stagionalità settimanale dei dati. Analizzando la funzione più nel dettaglio, sono significativi non solo i ritardi stagionali, indice di una non stazionarietà della serie storica. Proviamo quindi a considerare una differenza stagionale della serie storica.

```{r}
diff7_ristorante1 <- diff(ristorante1_xts_subset,7)
autoplot(diff7_ristorante1)
```

```{r}
Acf(diff7_ristorante1, 70)
Pacf(diff7_ristorante1, 70)
```

La funzione di autocorrelazione della serie storica differenziata stagionalmente evidenza un miglioramento in termini di ritardi significativi, anche se permangono autocorrelazioni significative ad alcuni ritardi (2,7 in particolare). Per quanto riguarda la funzione di autocorrelazione parziale i ritardi che presentano autocorrelazioni significative aumentano decisamente.

```{r}
diff(diff7_ristorante1) %>% autoplot()
```

```{r}
diff(diff7_ristorante1) %>% Acf()
diff(diff7_ristorante1) %>% Pacf()
```

La differenza stagionale ha portato miglioramenti in termini di Acf e Pacf, mentre la differenza semplice(applicata alla serie storica già differenziata stagionalmente) non ha migliorato la situazione. Procediamo considerando la serie storica differenziata solo stagionalmente. \\

Proviamo a considerare una trasformazione logaritmica per esplorare una possibile non stazionarietà in varianza.

```{r}
log(ristorante1_xts_subset) %>% autoplot()
```

La situazione non sembra cambiare. Tramite la funzione BoxCox.lambda andiamo a vedere quale sarebbe stato il valore di lambda stimato da R (ricordiamo che se =0 allora trasformazione logaritmica)

```{r}
BoxCox.lambda(ristorante1_xts_subset)
```

```{r}
BoxCox(ristorante1_xts_subset, lambda = "auto") %>% autoplot()
```

```{r}
diff(BoxCox(ristorante1_xts_subset, lambda = "auto"),7) %>% autoplot()
```

```{r}
diff(BoxCox(ristorante1_xts_subset, lambda = "auto"),7) %>% Acf()
diff(BoxCox(ristorante1_xts_subset, lambda = "auto"),7) %>% Pacf()
```

L'Acf e la Pacf della serie storica a cui viene applicato una trasformazione di BoxCox e differenziata stagionalmente sembra aver ulteriormente migliorato i risultato in termini di stazionarietà della serie storica. Bisognerà poi verificare se è possibile applicare una differenziazione stagionale all'interno della specificazione del modello (non è detto che il modello riesca a beccare la stagionalità) oppure se è necessario dare in pasto al modello la serie storica differenziata di ordine 7

Procediamo quindi alla fase di specificazione di un modello della classe Arima.

```{r}
# Salviamo la serie storica differenziata di ordine 7
ristorante1_xts_subset_diff <- diff(ristorante1_xts_subset, 7)
```

## Specificazione del modello

```{r}
# Divisione training and test della serie storica originaria
train <- head(ristorante1_xts_subset, round(length(ristorante1_xts_subset) * 0.8))
h <- length(ristorante1_xts_subset) - length(train)
test <- tail(ristorante1_xts_subset, h)
```
```{r}
# Divisione training and test della serie storica differnziata di ordine 7
train_diff <- head(ristorante1_xts_subset_diff, round(length(ristorante1_xts_subset_diff) * 0.8))
h_diff <- length(ristorante1_xts_subset_diff) - length(train_diff)
test_diff <- tail(ristorante1_xts_subset_diff, h_diff)
```

```{r}
mod1 <- Arima(train, order = c(7,1,7), seasonal = c(0,0,0))
Acf(mod1$residuals)
Pacf(mod1$residuals)
summary(mod1)
```

```{r}
# Significatività dei parametri (p-value)
(1-pnorm(abs(mod1$coef)/sqrt(diag(mod1$var.coef))))*2
```

Valutiamo se i residui presentano autocorrelazione seriale.

```{r}
Box.test(residuals(mod1),lag=28,type="Ljung-Box")
```


Previsione e confronto con il test set

```{r}
# Previsioni modello Arima
forecast(mod1, 108) %>% autoplot()
```

```{r}
# Sistemare
fitted_mod1 <- as.data.frame()
fitted_mod1['Date'] <- ristorante1[677:784,6]
fitted_mod1_xts <- as.xts(fitted_mod1[,-2], order.by = fitted_mod1[,2])
diff_fitt_test <- test - fitted_mod1_xts
```

```{r}
plot(test,
     col=2
     )
lines(fitted_mod1_xts,
      col=4
      )
legend("topright",
       c("Test", "Fitted"),
       col=c(2,4)
       )
```

```{r}
mean(diff_fitt_test)
plot(diff_fitt_test)
```


```{r}
# Serie storica differenziata di ordine 7
mod2 <- Arima(train_diff, c(7,0,7), c(0,0,0))
```
```{r}
Acf(mod2$residuals)
Pacf(mod2$residuals)
summary(mod2)
```
### Aggregazione: serie storica settimanale

```{r}
head(ristorante1_xts) # I dati partono da sabato
tail(ristorante1_xts) #  I dati finiscono di sabato (ultimoe e penultimo valori 0.0)
```
```{r}
# Droppo le prime due righe così da avere la serie storica che parte da lunedì e finisce di domenica
ristorante1_xts <- ristorante1_xts[-c(1,2)]
ristorante1_xts <- ristorante1_xts[-c(1329,1330,1331,1332,1333,1334)]
head(ristorante1_xts)
tail(ristorante1_xts)
```
```{r}
ristorante1_weekly <- apply.weekly(ristorante1_xts[-c(1,2)], mean)
```

```{r}
head(ristorante1_weekly)
tail(ristorante1_weekly)
```

```{r}
plot(ristorante1_weekly)
```
```{r}
plot(apply.monthly(ristorante1_xts_subset, mean))
```
 
